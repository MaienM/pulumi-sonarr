// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

/**
 * <!-- subcategory:Media Management -->Media Management resource.
 * For more information refer to [Naming](https://wiki.servarr.com/sonarr/settings#file-management) documentation.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as sonarr from "@maienm/pulumi-sonarr";
 *
 * const example = new sonarr.mediamanagement.MediaManagement("example", {
 *     chmodFolder: "755",
 *     chownGroup: "arrs",
 *     createEmptyFolders: true,
 *     deleteEmptyFolders: true,
 *     downloadPropersRepacks: "preferAndUpgrade",
 *     enableMediaInfo: true,
 *     episodeTitleRequired: "always",
 *     extraFileExtensions: "srt,info",
 *     fileDate: "none",
 *     hardlinksCopy: true,
 *     importExtraFiles: true,
 *     minimumFreeSpace: 100,
 *     recycleBinDays: 7,
 *     recycleBinPath: "/bin",
 *     rescanAfterRefresh: "always",
 *     setPermissions: true,
 *     skipFreeSpaceCheck: true,
 *     unmonitorPreviousEpisodes: true,
 * });
 * ```
 *
 * ## Import
 *
 * import does not need parameters
 *
 * ```sh
 *  $ pulumi import sonarr:MediaManagement/mediaManagement:MediaManagement example
 * ```
 */
export class MediaManagement extends pulumi.CustomResource {
    /**
     * Get an existing MediaManagement resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: MediaManagementState, opts?: pulumi.CustomResourceOptions): MediaManagement {
        return new MediaManagement(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'sonarr:MediaManagement/mediaManagement:MediaManagement';

    /**
     * Returns true if the given object is an instance of MediaManagement.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is MediaManagement {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === MediaManagement.__pulumiType;
    }

    /**
     * Permission in linux format.
     */
    public readonly chmodFolder!: pulumi.Output<string>;
    /**
     * Group used for permission.
     */
    public readonly chownGroup!: pulumi.Output<string>;
    /**
     * Create empty series directories.
     */
    public readonly createEmptyFolders!: pulumi.Output<boolean>;
    /**
     * Delete empty series directories.
     */
    public readonly deleteEmptyFolders!: pulumi.Output<boolean>;
    /**
     * Download proper and repack policy. valid inputs are: 'preferAndUpgrade', 'doNotUpgrade', and 'doNotPrefer'.
     */
    public readonly downloadPropersRepacks!: pulumi.Output<string>;
    /**
     * Scan files details.
     */
    public readonly enableMediaInfo!: pulumi.Output<boolean>;
    /**
     * Episode title requirement policy. valid inputs are: 'always', 'bulkSeasonReleases' and 'never'.
     */
    public readonly episodeTitleRequired!: pulumi.Output<string>;
    /**
     * Comma separated list of extra files to import (.nfo will be imported as .nfo-orig).
     */
    public readonly extraFileExtensions!: pulumi.Output<string>;
    /**
     * Define the file date modification. valid inputs are: 'none', 'localAirDate, and 'utcAirDate'.
     */
    public readonly fileDate!: pulumi.Output<string>;
    /**
     * Use hardlinks instead of copy.
     */
    public readonly hardlinksCopy!: pulumi.Output<boolean>;
    /**
     * Import extra files. If enabled it will leverage 'extra*file*extensions'.
     */
    public readonly importExtraFiles!: pulumi.Output<boolean>;
    /**
     * Minimum free space in MB to allow import.
     */
    public readonly minimumFreeSpace!: pulumi.Output<number>;
    /**
     * Recyle bin days of retention.
     */
    public readonly recycleBinDays!: pulumi.Output<number>;
    /**
     * Recycle bin absolute path.
     */
    public readonly recycleBinPath!: pulumi.Output<string>;
    /**
     * Rescan after refresh policy. valid inputs are: 'always', 'afterManual' and 'never'.
     */
    public readonly rescanAfterRefresh!: pulumi.Output<string>;
    /**
     * Set permission for imported files.
     */
    public readonly setPermissions!: pulumi.Output<boolean>;
    /**
     * Skip free space check before importing.
     */
    public readonly skipFreeSpaceCheck!: pulumi.Output<boolean>;
    /**
     * Unmonitor deleted files.
     */
    public readonly unmonitorPreviousEpisodes!: pulumi.Output<boolean>;

    /**
     * Create a MediaManagement resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: MediaManagementArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: MediaManagementArgs | MediaManagementState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as MediaManagementState | undefined;
            resourceInputs["chmodFolder"] = state ? state.chmodFolder : undefined;
            resourceInputs["chownGroup"] = state ? state.chownGroup : undefined;
            resourceInputs["createEmptyFolders"] = state ? state.createEmptyFolders : undefined;
            resourceInputs["deleteEmptyFolders"] = state ? state.deleteEmptyFolders : undefined;
            resourceInputs["downloadPropersRepacks"] = state ? state.downloadPropersRepacks : undefined;
            resourceInputs["enableMediaInfo"] = state ? state.enableMediaInfo : undefined;
            resourceInputs["episodeTitleRequired"] = state ? state.episodeTitleRequired : undefined;
            resourceInputs["extraFileExtensions"] = state ? state.extraFileExtensions : undefined;
            resourceInputs["fileDate"] = state ? state.fileDate : undefined;
            resourceInputs["hardlinksCopy"] = state ? state.hardlinksCopy : undefined;
            resourceInputs["importExtraFiles"] = state ? state.importExtraFiles : undefined;
            resourceInputs["minimumFreeSpace"] = state ? state.minimumFreeSpace : undefined;
            resourceInputs["recycleBinDays"] = state ? state.recycleBinDays : undefined;
            resourceInputs["recycleBinPath"] = state ? state.recycleBinPath : undefined;
            resourceInputs["rescanAfterRefresh"] = state ? state.rescanAfterRefresh : undefined;
            resourceInputs["setPermissions"] = state ? state.setPermissions : undefined;
            resourceInputs["skipFreeSpaceCheck"] = state ? state.skipFreeSpaceCheck : undefined;
            resourceInputs["unmonitorPreviousEpisodes"] = state ? state.unmonitorPreviousEpisodes : undefined;
        } else {
            const args = argsOrState as MediaManagementArgs | undefined;
            if ((!args || args.chmodFolder === undefined) && !opts.urn) {
                throw new Error("Missing required property 'chmodFolder'");
            }
            if ((!args || args.chownGroup === undefined) && !opts.urn) {
                throw new Error("Missing required property 'chownGroup'");
            }
            if ((!args || args.createEmptyFolders === undefined) && !opts.urn) {
                throw new Error("Missing required property 'createEmptyFolders'");
            }
            if ((!args || args.deleteEmptyFolders === undefined) && !opts.urn) {
                throw new Error("Missing required property 'deleteEmptyFolders'");
            }
            if ((!args || args.downloadPropersRepacks === undefined) && !opts.urn) {
                throw new Error("Missing required property 'downloadPropersRepacks'");
            }
            if ((!args || args.enableMediaInfo === undefined) && !opts.urn) {
                throw new Error("Missing required property 'enableMediaInfo'");
            }
            if ((!args || args.episodeTitleRequired === undefined) && !opts.urn) {
                throw new Error("Missing required property 'episodeTitleRequired'");
            }
            if ((!args || args.extraFileExtensions === undefined) && !opts.urn) {
                throw new Error("Missing required property 'extraFileExtensions'");
            }
            if ((!args || args.fileDate === undefined) && !opts.urn) {
                throw new Error("Missing required property 'fileDate'");
            }
            if ((!args || args.hardlinksCopy === undefined) && !opts.urn) {
                throw new Error("Missing required property 'hardlinksCopy'");
            }
            if ((!args || args.importExtraFiles === undefined) && !opts.urn) {
                throw new Error("Missing required property 'importExtraFiles'");
            }
            if ((!args || args.minimumFreeSpace === undefined) && !opts.urn) {
                throw new Error("Missing required property 'minimumFreeSpace'");
            }
            if ((!args || args.recycleBinDays === undefined) && !opts.urn) {
                throw new Error("Missing required property 'recycleBinDays'");
            }
            if ((!args || args.recycleBinPath === undefined) && !opts.urn) {
                throw new Error("Missing required property 'recycleBinPath'");
            }
            if ((!args || args.rescanAfterRefresh === undefined) && !opts.urn) {
                throw new Error("Missing required property 'rescanAfterRefresh'");
            }
            if ((!args || args.setPermissions === undefined) && !opts.urn) {
                throw new Error("Missing required property 'setPermissions'");
            }
            if ((!args || args.skipFreeSpaceCheck === undefined) && !opts.urn) {
                throw new Error("Missing required property 'skipFreeSpaceCheck'");
            }
            if ((!args || args.unmonitorPreviousEpisodes === undefined) && !opts.urn) {
                throw new Error("Missing required property 'unmonitorPreviousEpisodes'");
            }
            resourceInputs["chmodFolder"] = args ? args.chmodFolder : undefined;
            resourceInputs["chownGroup"] = args ? args.chownGroup : undefined;
            resourceInputs["createEmptyFolders"] = args ? args.createEmptyFolders : undefined;
            resourceInputs["deleteEmptyFolders"] = args ? args.deleteEmptyFolders : undefined;
            resourceInputs["downloadPropersRepacks"] = args ? args.downloadPropersRepacks : undefined;
            resourceInputs["enableMediaInfo"] = args ? args.enableMediaInfo : undefined;
            resourceInputs["episodeTitleRequired"] = args ? args.episodeTitleRequired : undefined;
            resourceInputs["extraFileExtensions"] = args ? args.extraFileExtensions : undefined;
            resourceInputs["fileDate"] = args ? args.fileDate : undefined;
            resourceInputs["hardlinksCopy"] = args ? args.hardlinksCopy : undefined;
            resourceInputs["importExtraFiles"] = args ? args.importExtraFiles : undefined;
            resourceInputs["minimumFreeSpace"] = args ? args.minimumFreeSpace : undefined;
            resourceInputs["recycleBinDays"] = args ? args.recycleBinDays : undefined;
            resourceInputs["recycleBinPath"] = args ? args.recycleBinPath : undefined;
            resourceInputs["rescanAfterRefresh"] = args ? args.rescanAfterRefresh : undefined;
            resourceInputs["setPermissions"] = args ? args.setPermissions : undefined;
            resourceInputs["skipFreeSpaceCheck"] = args ? args.skipFreeSpaceCheck : undefined;
            resourceInputs["unmonitorPreviousEpisodes"] = args ? args.unmonitorPreviousEpisodes : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(MediaManagement.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering MediaManagement resources.
 */
export interface MediaManagementState {
    /**
     * Permission in linux format.
     */
    chmodFolder?: pulumi.Input<string>;
    /**
     * Group used for permission.
     */
    chownGroup?: pulumi.Input<string>;
    /**
     * Create empty series directories.
     */
    createEmptyFolders?: pulumi.Input<boolean>;
    /**
     * Delete empty series directories.
     */
    deleteEmptyFolders?: pulumi.Input<boolean>;
    /**
     * Download proper and repack policy. valid inputs are: 'preferAndUpgrade', 'doNotUpgrade', and 'doNotPrefer'.
     */
    downloadPropersRepacks?: pulumi.Input<string>;
    /**
     * Scan files details.
     */
    enableMediaInfo?: pulumi.Input<boolean>;
    /**
     * Episode title requirement policy. valid inputs are: 'always', 'bulkSeasonReleases' and 'never'.
     */
    episodeTitleRequired?: pulumi.Input<string>;
    /**
     * Comma separated list of extra files to import (.nfo will be imported as .nfo-orig).
     */
    extraFileExtensions?: pulumi.Input<string>;
    /**
     * Define the file date modification. valid inputs are: 'none', 'localAirDate, and 'utcAirDate'.
     */
    fileDate?: pulumi.Input<string>;
    /**
     * Use hardlinks instead of copy.
     */
    hardlinksCopy?: pulumi.Input<boolean>;
    /**
     * Import extra files. If enabled it will leverage 'extra*file*extensions'.
     */
    importExtraFiles?: pulumi.Input<boolean>;
    /**
     * Minimum free space in MB to allow import.
     */
    minimumFreeSpace?: pulumi.Input<number>;
    /**
     * Recyle bin days of retention.
     */
    recycleBinDays?: pulumi.Input<number>;
    /**
     * Recycle bin absolute path.
     */
    recycleBinPath?: pulumi.Input<string>;
    /**
     * Rescan after refresh policy. valid inputs are: 'always', 'afterManual' and 'never'.
     */
    rescanAfterRefresh?: pulumi.Input<string>;
    /**
     * Set permission for imported files.
     */
    setPermissions?: pulumi.Input<boolean>;
    /**
     * Skip free space check before importing.
     */
    skipFreeSpaceCheck?: pulumi.Input<boolean>;
    /**
     * Unmonitor deleted files.
     */
    unmonitorPreviousEpisodes?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a MediaManagement resource.
 */
export interface MediaManagementArgs {
    /**
     * Permission in linux format.
     */
    chmodFolder: pulumi.Input<string>;
    /**
     * Group used for permission.
     */
    chownGroup: pulumi.Input<string>;
    /**
     * Create empty series directories.
     */
    createEmptyFolders: pulumi.Input<boolean>;
    /**
     * Delete empty series directories.
     */
    deleteEmptyFolders: pulumi.Input<boolean>;
    /**
     * Download proper and repack policy. valid inputs are: 'preferAndUpgrade', 'doNotUpgrade', and 'doNotPrefer'.
     */
    downloadPropersRepacks: pulumi.Input<string>;
    /**
     * Scan files details.
     */
    enableMediaInfo: pulumi.Input<boolean>;
    /**
     * Episode title requirement policy. valid inputs are: 'always', 'bulkSeasonReleases' and 'never'.
     */
    episodeTitleRequired: pulumi.Input<string>;
    /**
     * Comma separated list of extra files to import (.nfo will be imported as .nfo-orig).
     */
    extraFileExtensions: pulumi.Input<string>;
    /**
     * Define the file date modification. valid inputs are: 'none', 'localAirDate, and 'utcAirDate'.
     */
    fileDate: pulumi.Input<string>;
    /**
     * Use hardlinks instead of copy.
     */
    hardlinksCopy: pulumi.Input<boolean>;
    /**
     * Import extra files. If enabled it will leverage 'extra*file*extensions'.
     */
    importExtraFiles: pulumi.Input<boolean>;
    /**
     * Minimum free space in MB to allow import.
     */
    minimumFreeSpace: pulumi.Input<number>;
    /**
     * Recyle bin days of retention.
     */
    recycleBinDays: pulumi.Input<number>;
    /**
     * Recycle bin absolute path.
     */
    recycleBinPath: pulumi.Input<string>;
    /**
     * Rescan after refresh policy. valid inputs are: 'always', 'afterManual' and 'never'.
     */
    rescanAfterRefresh: pulumi.Input<string>;
    /**
     * Set permission for imported files.
     */
    setPermissions: pulumi.Input<boolean>;
    /**
     * Skip free space check before importing.
     */
    skipFreeSpaceCheck: pulumi.Input<boolean>;
    /**
     * Unmonitor deleted files.
     */
    unmonitorPreviousEpisodes: pulumi.Input<boolean>;
}
